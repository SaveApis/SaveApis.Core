schema {
  query: Query
  mutation: Mutation
}

type Query {
  projects: [ProjectGetDto!]!
  projectById(id: String!): ProjectGetDto!
  users(order: [UserGetDtoSortInput!] where: UserGetDtoFilterInput): [UserGetDto!]!
  userById(id: UUID!): UserGetDto!
}

type Mutation {
  login(dto: UserLoginDtoInput!): String!
  projectLogin(dto: ProjectLoginDtoInput!): Boolean!
  createProject(dto: ProjectCreateDtoInput!): ProjectGetDto!
  updateProject(id: String! dto: ProjectUpdateDtoInput!): ProjectGetDto!
  deleteProject(id: String!): String!
  activateProject(id: String!): ProjectGetDto!
  deactivateProject(id: String!): ProjectGetDto!
  addUserToProject(projectId: String! userId: UUID!): ProjectGetDto!
  addUsersToProject(projectId: String! userIds: [UUID!]!): ProjectGetDto!
  removeUserFromProject(projectId: String! userId: UUID!): ProjectGetDto!
  removeUsersFromProject(projectId: String! userIds: [UUID!]!): ProjectGetDto!
  createDeveloperUser(dto: UserCreateDtoInput!): UserGetDto!
  createAdministratorUser(dto: UserCreateDtoInput!): UserGetDto!
  createManagerUser(dto: UserCreateDtoInput!): UserGetDto!
  createUser(dto: UserCreateDtoInput!): UserGetDto!
  updateUser(id: UUID! dto: UserUpdateDtoInput!): UserGetDto!
  deleteUser(id: UUID!): UUID!
  activateUser(id: UUID!): UserGetDto!
  deactivateUser(id: UUID!): UserGetDto!
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
  "Before the resolver was executed."
  BEFORE_RESOLVER
  "After the resolver was executed."
  AFTER_RESOLVER
  "The policy is applied in the validation step before the execution."
  VALIDATION
}

input UserGetDtoSortInput {
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
  firstName: SortEnumType
  lastName: SortEnumType
  email: SortEnumType
  phone: SortEnumType
  role: SortEnumType
  userName: SortEnumType
  active: SortEnumType
}

input UserGetDtoFilterInput {
  and: [UserGetDtoFilterInput!]
  or: [UserGetDtoFilterInput!]
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  firstName: StringOperationFilterInput
  lastName: StringOperationFilterInput
  email: StringOperationFilterInput
  phone: StringOperationFilterInput
  role: SsoRoleOperationFilterInput
  userName: StringOperationFilterInput
  active: BooleanOperationFilterInput
}

enum SortEnumType {
  ASC
  DESC
}

input UuidOperationFilterInput {
  eq: UUID
  neq: UUID
  in: [UUID]
  nin: [UUID]
  gt: UUID
  ngt: UUID
  gte: UUID
  ngte: UUID
  lt: UUID
  nlt: UUID
  lte: UUID
  nlte: UUID
}

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input SsoRoleOperationFilterInput {
  eq: SsoRole
  neq: SsoRole
  in: [SsoRole!]
  nin: [SsoRole!]
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

scalar UUID

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

input ProjectUpdateDtoInput {
  name: String!
  description: String!
}

input ProjectCreateDtoInput {
  id: String!
  name: String!
  description: String!
  users: [UUID!]!
}

type ProjectGetDto {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  description: String!
  active: Boolean!
  users: [UserGetDto!]!
}

input ProjectLoginDtoInput {
  id: String!
  userName: String!
  password: String!
}

input UserLoginDtoInput {
  userName: String!
  password: String!
}

type UserGetDto {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime
  firstName: String!
  lastName: String!
  email: String!
  phone: String
  role: SsoRole!
  userName: String!
  active: Boolean!
}

input UserCreateDtoInput {
  firstName: String!
  lastName: String!
  email: String!
  phone: String
  userName: String!
}

input UserUpdateDtoInput {
  firstName: String!
  lastName: String!
  email: String!
  phone: String
  userName: String!
}

enum SsoRole {
  DEVELOPER
  ADMINISTRATOR
  MANAGER
  USER
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION